[{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Peter Solymos. Maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Solymos P (2024). intrval: Relational Operators Intervals. R package version 0.1-3, https://github.com/psolymos/intrval.","code":"@Manual{,   title = {intrval: Relational Operators for Intervals},   author = {Peter Solymos},   year = {2024},   note = {R package version 0.1-3},   url = {https://github.com/psolymos/intrval}, }"},{"path":"/index.html","id":"intrval-relational-operators-for-intervals","dir":"","previous_headings":"","what":"Relational Operators for Intervals","title":"Relational Operators for Intervals","text":"Evaluating values vectors within different open/closed intervals (x %[]% c(, b)), two closed intervals overlap (c(a1, b1) %[]o[]% c(a2, b2)). Operators negation directional relations also implemented.","code":""},{"path":"/index.html","id":"install","dir":"","previous_headings":"","what":"Install","title":"Relational Operators for Intervals","text":"Install CRAN: Install development version GitHub: User visible changes listed NEWS file. Use issue tracker report problem.","code":"install.packages(\"intrval\") if (!requireNamespace(\"remotes\")) install.packages(\"remotes\") remotes::install_github(\"psolymos/intrval\")"},{"path":"/index.html","id":"value-to-interval-relations","dir":"","previous_headings":"","what":"Value-to-interval relations","title":"Relational Operators for Intervals","text":"Values x compared interval endpoints b (<= b). Endpoints can defined vector two values (c(, b)): values compared single interval value x. endpoints stored matrix-like object list, comparisons made element-wise. lengths match, shorter objects recycled. Return values logicals. Note: interval endpoints sorted internally thus ensuring condition <= b necessary. value--interval operators work numeric (integer, real) ordered vectors, object types measured least ordinal scale (e.g. dates).","code":"x <- rep(4, 5) a <- 1:5 b <- 3:7 cbind(x=x, a=a, b=b) x %[]% cbind(a, b) # matrix x %[]% data.frame(a=a, b=b) # data.frame x %[]% list(a, b) # list"},{"path":"/index.html","id":"closed-and-open-intervals","dir":"","previous_headings":"Value-to-interval relations","what":"Closed and open intervals","title":"Relational Operators for Intervals","text":"following special operators used indicate closed ([, ]) open ((, )) interval endpoints:","code":""},{"path":[]},{"path":"/index.html","id":"dividing-a-range-into-3-intervals","dir":"","previous_headings":"Value-to-interval relations","what":"Dividing a range into 3 intervals","title":"Relational Operators for Intervals","text":"functions %[c]%, %[c)%, %(c]%, %(c)% return integer vector taking values (c within brackets refer ‘cut’): -1L value less equal (<= b), depending interval type, 0L value inside interval, 1L value greater equal b (<= b), depending interval type.","code":""},{"path":"/index.html","id":"interval-to-interval-relations","dir":"","previous_headings":"","what":"Interval-to-interval relations","title":"Relational Operators for Intervals","text":"operators define open/closed nature lower/upper limits intervals left right hand side o middle. overlap two closed intervals, [a1, b1] [a2, b2], evaluated %[o]% (alias %[]o[]%) operator (a1 <= b1, a2 <= b2). Endpoints can defined vector two values (c(a1, b1))can stored matrix-like objects lists case comparisons made element-wise. lengths match, shorter objects recycled. value--interval operators work numeric (integer, real) ordered vectors, object types measured least ordinal scale (e.g. dates), see Examples. Note: interval endpoints sorted internally thus ensuring conditions a1 <= b1 a2 <= b2 necessary. lengths match, shorter objects recycled. value--interval operators work numeric (integer, real) ordered vectors, object types measured least ordinal scale (e.g. dates). %)o(% used negation two closed interval overlap, directional evaluation done via operators %[<o]% %[o>]%. overlap two open intervals evaluated %(o)% (alias %()o()%). %]o[% used negation two open interval overlap, directional evaluation done via operators %(<o)% %(o>)%. Overlap operators mixed endpoint negation directional counterparts.","code":"c(2, 3) %[]o[]% c(0, 1) list(0:4, 1:5) %[]o[]% c(2, 3) cbind(0:4, 1:5) %[]o[]% c(2, 3) data.frame(a=0:4, b=1:5) %[]o[]% c(2, 3)"},{"path":"/index.html","id":"operators-for-discrete-variables","dir":"","previous_headings":"","what":"Operators for discrete variables","title":"Relational Operators for Intervals","text":"previous operators return NA unordered factors. Set overlap can evaluated base %% operator negation %ni% (, opposite ). %nin% %notin% aliases better code readability (%% can look much like %ni%).","code":""},{"path":[]},{"path":"/index.html","id":"bounding-box","dir":"","previous_headings":"Examples","what":"Bounding box","title":"Relational Operators for Intervals","text":"","code":"set.seed(1) n <- 10^4 x <- runif(n, -2, 2) y <- runif(n, -2, 2) d <- sqrt(x^2 + y^2) iv1 <- x %[]% c(-0.25, 0.25) & y %[]% c(-1.5, 1.5) iv2 <- x %[]% c(-1.5, 1.5) & y %[]% c(-0.25, 0.25) iv3 <- d %()% c(1, 1.5) plot(x, y, pch = 19, cex = 0.25, col = iv1 + iv2 + 1,     main = \"Intersecting bounding boxes\") plot(x, y, pch = 19, cex = 0.25, col = iv3 + 1,      main = \"Deck the halls:\\ndistance range from center\")"},{"path":"/index.html","id":"time-series-filtering","dir":"","previous_headings":"Examples","what":"Time series filtering","title":"Relational Operators for Intervals","text":"","code":"x <- seq(0, 4*24*60*60, 60*60) dt <- as.POSIXct(x, origin=\"2000-01-01 00:00:00\") f <- as.POSIXlt(dt)$hour %[]% c(0, 11) plot(sin(x) ~ dt, type=\"l\", col=\"grey\",     main = \"Filtering date/time objects\") points(sin(x) ~ dt, pch = 19, col = f + 1)"},{"path":"/index.html","id":"quality-control-chart-qcc","dir":"","previous_headings":"Examples","what":"Quality control chart (QCC)","title":"Relational Operators for Intervals","text":"","code":"library(qcc) data(pistonrings) mu <- mean(pistonrings$diameter[pistonrings$trial]) SD <- sd(pistonrings$diameter[pistonrings$trial]) x <- pistonrings$diameter[!pistonrings$trial] iv <- mu + 3 * c(-SD, SD) plot(x, pch = 19, col = x %)(% iv +1, type = \"b\", ylim = mu + 5 * c(-SD, SD),     main = \"Shewhart quality control chart\\ndiameter of piston rings\") abline(h = mu) abline(h = iv, lty = 2)"},{"path":"/index.html","id":"confidence-intervals-and-hypothesis-testing","dir":"","previous_headings":"Examples","what":"Confidence intervals and hypothesis testing","title":"Relational Operators for Intervals","text":"","code":"## Annette Dobson (1990) \"An Introduction to Generalized Linear Models\". ## Page 9: Plant Weight Data. ctl <- c(4.17,5.58,5.18,6.11,4.50,4.61,5.17,4.53,5.33,5.14) trt <- c(4.81,4.17,4.41,3.59,5.87,3.83,6.03,4.89,4.32,4.69) group <- gl(2, 10, 20, labels = c(\"Ctl\",\"Trt\")) weight <- c(ctl, trt)  lm.D9 <- lm(weight ~ group) ## compare 95% confidence intervals with 0 (CI.D9 <- confint(lm.D9)) #                2.5 %    97.5 % # (Intercept)  4.56934 5.4946602 # groupTrt    -1.02530 0.2833003 0 %[]% CI.D9 # (Intercept)    groupTrt #       FALSE        TRUE  lm.D90 <- lm(weight ~ group - 1) # omitting intercept ## compare 95% confidence of the 2 groups to each other (CI.D90 <- confint(lm.D90)) #            2.5 %  97.5 % # groupCtl 4.56934 5.49466 # groupTrt 4.19834 5.12366 CI.D90[1,] %[o]% CI.D90[2,] # 2.5 % #  TRUE"},{"path":"/index.html","id":"dates","dir":"","previous_headings":"Examples","what":"Dates","title":"Relational Operators for Intervals","text":"","code":"DATE <- as.Date(c(\"2000-01-01\",\"2000-02-01\", \"2000-03-31\")) DATE %[<]% as.Date(c(\"2000-01-15\", \"2000-03-15\")) # [1]  TRUE FALSE FALSE DATE %[]% as.Date(c(\"2000-01-15\", \"2000-03-15\")) # [1] FALSE  TRUE FALSE DATE %[>]% as.Date(c(\"2000-01-15\", \"2000-03-15\")) # [1] FALSE FALSE  TRUE  dt1 <- as.Date(c(\"2000-01-01\", \"2000-03-15\")) dt2 <- as.Date(c(\"2000-03-15\", \"2000-06-07\")) dt1 %[]o[]% dt2 # [1] TRUE dt1 %[]o[)% dt2 # [1] TRUE dt1 %[]o(]% dt2 # [1] FALSE dt1 %[]o()% dt2 # [1] FALSE"},{"path":"/index.html","id":"watch-precedence","dir":"","previous_headings":"Examples","what":"Watch precedence!","title":"Relational Operators for Intervals","text":"","code":"(2 * 1:5) %[]% (c(2, 3) * 2) # [1] FALSE  TRUE  TRUE FALSE FALSE 2 * 1:5 %[]% (c(2, 3) * 2) # [1] 0 0 0 2 2 (2 * 1:5) %[]% c(2, 3) * 2 # [1] 2 0 0 0 0 2 * 1:5 %[]% c(2, 3) * 2 # [1] 0 4 4 0 0"},{"path":"/index.html","id":"truncated-distributions","dir":"","previous_headings":"Examples","what":"Truncated distributions","title":"Relational Operators for Intervals","text":"Find math , implemented package truncdist.","code":"dtrunc <- function(x, ..., distr, lwr=-Inf, upr=Inf) {     f <- get(paste0(\"d\", distr), mode = \"function\")     F <- get(paste0(\"p\", distr), mode = \"function\")     Fx_lwr <- F(lwr, ..., log=FALSE)     Fx_upr <- F(upr, ..., log=FALSE)     fx     <- f(x,   ..., log=FALSE)     fx / (Fx_upr - Fx_lwr) * (x %[]% c(lwr, upr)) } n <- 10^4 curve(dtrunc(x, distr=\"norm\"), -2.5, 2.5, ylim=c(0, 2), ylab=\"f(x)\") curve(dtrunc(x, distr=\"norm\", lwr=-0.5, upr=0.1), add=TRUE, col=4, n=n) curve(dtrunc(x, distr=\"norm\", lwr=-0.75, upr=0.25), add=TRUE, col=3, n=n) curve(dtrunc(x, distr=\"norm\", lwr=-1, upr=1), add=TRUE, col=2, n=n)"},{"path":"/index.html","id":"shiny-example-1-regular-slider","dir":"","previous_headings":"Examples","what":"Shiny example 1: regular slider","title":"Relational Operators for Intervals","text":"","code":"library(shiny) library(intrval) library(qcc)  data(pistonrings) mu <- mean(pistonrings$diameter[pistonrings$trial]) SD <- sd(pistonrings$diameter[pistonrings$trial]) x <- pistonrings$diameter[!pistonrings$trial]  ## UI function ui <- fluidPage(   plotOutput(\"plot\"),   sliderInput(\"x\", \"x SD:\",     min=0, max=5, value=0, step=0.1,     animate=animationOptions(100)   ) )  # Server logic server <- function(input, output) {   output$plot <- renderPlot({     Main <- paste(\"Shewhart quality control chart\",          \"diameter of piston rings\", sprintf(\"+/- %.1f SD\", input$x),         sep=\"\\n\")     iv <- mu + input$x * c(-SD, SD)     plot(x, pch = 19, col = x %)(% iv +1, type = \"b\",          ylim = mu + 5 * c(-SD, SD), main = Main)     abline(h = mu)     abline(h = iv, lty = 2)   }) }  ## Run shiny app if (interactive()) shinyApp(ui, server)"},{"path":"/index.html","id":"shiny-example-2-range-slider","dir":"","previous_headings":"Examples","what":"Shiny example 2: range slider","title":"Relational Operators for Intervals","text":"","code":"library(shiny) library(intrval)  set.seed(1) n <- 10^4 x <- round(runif(n, -2, 2), 2) y <- round(runif(n, -2, 2), 2) d <- round(sqrt(x^2 + y^2), 2)  ## UI function ui <- fluidPage(   titlePanel(\"intrval example with shiny\"),   sidebarLayout(     sidebarPanel(       sliderInput(\"bb_x\", \"x value:\",         min=min(x), max=max(x), value=range(x),          step=round(diff(range(x))/20, 1), animate=TRUE       ),       sliderInput(\"bb_y\", \"y value:\",         min = min(y), max = max(y), value = range(y),         step=round(diff(range(y))/20, 1), animate=TRUE       ),       sliderInput(\"bb_d\", \"radial distance:\",         min = 0, max = max(d), value = c(0, max(d)/2),         step=round(max(d)/20, 1), animate=TRUE       )     ),     mainPanel(       plotOutput(\"plot\")     )   ) )  # Server logic server <- function(input, output) {   output$plot <- renderPlot({     iv1 <- x %[]% input$bb_x & y %[]% input$bb_y     iv2 <- x %[]% input$bb_y & y %[]% input$bb_x     iv3 <- d %()% input$bb_d     op <- par(mfrow=c(1,2))     plot(x, y, pch = 19, cex = 0.25, col = iv1 + iv2 + 3,         main = \"Intersecting bounding boxes\")     plot(x, y, pch = 19, cex = 0.25, col = iv3 + 1,          main = \"Deck the halls:\\ndistance range from center\")     par(op)   }) }  ## Run shiny app if (interactive()) shinyApp(ui, server)"},{"path":"/reference/cut.html","id":null,"dir":"Reference","previous_headings":"","what":"Dividing a Range Into 3 Intervals — %[c]%","title":"Dividing a Range Into 3 Intervals — %[c]%","text":"Functions evaluating values vectors within intervals, less higher interval endpoints. c within brackets refer cut, similar function.","code":""},{"path":"/reference/cut.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dividing a Range Into 3 Intervals — %[c]%","text":"","code":"x %[c]% interval x %[c)% interval x %(c]% interval x %(c)% interval"},{"path":"/reference/cut.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Dividing a Range Into 3 Intervals — %[c]%","text":"x vector NULL: values compared interval endpoints. interval vector, 2-column matrix, list, NULL: interval end points.","code":""},{"path":"/reference/cut.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Dividing a Range Into 3 Intervals — %[c]%","text":"Values x compared interval endpoints b (<= b) (see %[]% details). functions return integer vector taking values -1L (value x less equal , depending interval type), 0L (value x inside interval), 1L (value x greater equal b, depending interval type).","code":""},{"path":"/reference/cut.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Dividing a Range Into 3 Intervals — %[c]%","text":"Peter Solymos <solymos@ualberta.ca>","code":""},{"path":[]},{"path":"/reference/cut.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Dividing a Range Into 3 Intervals — %[c]%","text":"","code":"x <- 1:5 x %[c]% c(2,4) #> [1] -1  0  0  0  1 x %[c)% c(2,4) #> [1] -1  0  0  1  1 x %(c]% c(2,4) #> [1] -1 -1  0  0  1 x %(c)% c(2,4) #> [1] -1 -1  0  1  1"},{"path":"/reference/intrval-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Relational Operators for Intervals — intrval-package","title":"Relational Operators for Intervals — intrval-package","text":"Evaluating values   vectors within different open/closed intervals   (`x %[]% c(, b)`), two closed   intervals overlap (`c(a1, b1) %[]o[]% c(a2, b2)`).   Operators negation directional relations also implemented.","code":""},{"path":"/reference/intrval-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Relational Operators for Intervals — intrval-package","text":"DESCRIPTION file: package yet installed build time.   Index:  package yet installed build time. Relational operators value--interval comparisons: %[]% alikes. Relational operators interval--interval comparisons: %[o]% alikes. Negated value matching: %ni%.","code":""},{"path":"/reference/intrval-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Relational Operators for Intervals — intrval-package","text":"Peter Solymos [cre, aut] (<https://orcid.org/0000-0001-7337-1740>) Maintainer: Peter Solymos <psolymos@gmail.com>","code":""},{"path":"/reference/intrval.html","id":null,"dir":"Reference","previous_headings":"","what":"Relational Operators Comparing Values to Intervals — intrval","title":"Relational Operators Comparing Values to Intervals — intrval","text":"Functions evaluating values vectors within intervals.","code":""},{"path":"/reference/intrval.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Relational Operators Comparing Values to Intervals — intrval","text":"","code":"x %[]% interval x %)(% interval x %[<]% interval x %[>]% interval  x %[)% interval x %)[% interval x %[<)% interval x %[>)% interval  x %(]% interval x %](% interval x %(<]% interval x %(>]% interval  x %()% interval x %][% interval x %(<)% interval x %(>)% interval  intrval_types(type = NULL, plot = FALSE)"},{"path":"/reference/intrval.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Relational Operators Comparing Values to Intervals — intrval","text":"x vector NULL: values compared interval endpoints. interval vector, 2-column matrix, list, NULL: interval end points. type character, type operator subsetting results. default NULL means types displayed. plot logical, whether plot results, print table console instead.","code":""},{"path":"/reference/intrval.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Relational Operators Comparing Values to Intervals — intrval","text":"Values x compared interval endpoints b (<= b). Endpoints can defined vector two values (c(, b)): values compared single interval value x. endpoints stored matrix-like object list, comparisons made element-wise. lengths match, shorter objects recycled. value--interval operators work numeric (integer, real) ordered vectors, object types measured least ordinal scale (e.g. dates), see Examples. Note: interval endpoints sorted internally thus ensuring condition <= b necessary. type argument specification special function determines open (( )) closed ([ ]) endpoints relations. four types intervals ([], [), (], ()), negation ()(, )[, ](, ][, respectively), less ([<], [<), (<], (<)), greater ([>], [>), (>], (>)) relations. Note operators return identical results syntactically different: %[<]% %[<)% evaluate x < ; %[>]% %(>]% evaluate x > b; %(<]% %(<)% evaluate x <= ; %[>)% %(>)% evaluate x >= b. evaluate one end interval still conceptually referring relationship defined right-hand-side interval object given <= b. implies 2 conditional logical evaluations instead treating single 3-level ordered factor.","code":""},{"path":"/reference/intrval.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Relational Operators Comparing Values to Intervals — intrval","text":"logical vector, indicating x specified interval. Values TRUE, FALSE, NA (3 values (x endpoints interval) NA). helper function intrval_types can used understand visualize operators' effects. returns matrix explaining properties operators.","code":""},{"path":"/reference/intrval.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Relational Operators Comparing Values to Intervals — intrval","text":"Peter Solymos <solymos@ualberta.ca>","code":""},{"path":[]},{"path":"/reference/intrval.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Relational Operators Comparing Values to Intervals — intrval","text":"","code":"## motivating example from example(lm)  ## Annette Dobson (1990) \"An Introduction to Generalized Linear Models\". ## Page 9: Plant Weight Data. ctl <- c(4.17,5.58,5.18,6.11,4.50,4.61,5.17,4.53,5.33,5.14) trt <- c(4.81,4.17,4.41,3.59,5.87,3.83,6.03,4.89,4.32,4.69) group <- gl(2, 10, 20, labels = c(\"Ctl\",\"Trt\")) weight <- c(ctl, trt) lm.D9 <- lm(weight ~ group) ## compare 95% confidence intervals with 0 (CI.D9 <- confint(lm.D9)) #>                2.5 %    97.5 % #> (Intercept)  4.56934 5.4946602 #> groupTrt    -1.02530 0.2833003 0 %[]% CI.D9 #> (Intercept)    groupTrt  #>       FALSE        TRUE   ## comparing dates  DATE <- as.Date(c(\"2000-01-01\",\"2000-02-01\", \"2000-03-31\")) DATE %[<]% as.Date(c(\"2000-01-151\", \"2000-03-15\")) #> [1]  TRUE FALSE FALSE DATE %[]% as.Date(c(\"2000-01-151\", \"2000-03-15\")) #> [1] FALSE  TRUE FALSE DATE %[>]% as.Date(c(\"2000-01-151\", \"2000-03-15\")) #> [1] FALSE FALSE  TRUE  ## interval formats  x <- rep(4, 5) a <- 1:5 b <- 3:7 cbind(x=x, a=a, b=b) #>      x a b #> [1,] 4 1 3 #> [2,] 4 2 4 #> [3,] 4 3 5 #> [4,] 4 4 6 #> [5,] 4 5 7 x %[]% cbind(a, b) # matrix #> [1] FALSE  TRUE  TRUE  TRUE FALSE x %[]% data.frame(a=a, b=b) # data.frame #> [1] FALSE  TRUE  TRUE  TRUE FALSE x %[]% list(a, b) # list #> [1] FALSE  TRUE  TRUE  TRUE FALSE  ## helper functions  intrval_types() # print #>          Expression         Visual         Condition       #> %[]%     x %[]% c(a, b)     ---x===x---    x >= a & x <= b #> %)(%     x %)(% c(a, b)     ===o---o===    x < a | x > b   #> %[<]%    x %[<]% c(a, b)    ===o---o---    x < a           #> %[>]%    x %[>]% c(a, b)    ---o---o===    x > b           #> %[)%     x %[)% c(a, b)     ---x===o---    x >= a & x < b  #> %)[%     x %)[% c(a, b)     ===o---x===    x < a | x >= b  #> %[<)%    x %[<)% c(a, b)    ===o---o---    x < a           #> %[>)%    x %[>)% c(a, b)    ---o---x===    x >= b          #> %(]%     x %(]% c(a, b)     ---o===x---    x > a & x <= b  #> %](%     x %](% c(a, b)     ===x---o===    x <= a | x > b  #> %(<]%    x %(<]% c(a, b)    ===x---o---    x <= a          #> %(>]%    x %(>]% c(a, b)    ---o---o===    x > b           #> %()%     x %()% c(a, b)     ---o===o---    x > a & x < b   #> %][%     x %][% c(a, b)     ===x---x===    x <= a | x >= b #> %(<)%    x %(<)% c(a, b)    ===x---o---    x <= a          #> %(>)%    x %(>)% c(a, b)    ---o---x===    x >= b          intrval_types(plot = TRUE) # plot   ## graphical examples  ## bounding box set.seed(1) n <- 10^4 x <- runif(n, -2, 2) y <- runif(n, -2, 2) iv1 <- x %[]% c(-1, 1) & y %[]% c(-1, 1) plot(x, y, pch = 19, cex = 0.25, col = iv1 + 1, main = \"Bounding box\")   ## time series filtering x <- seq(0, 4*24*60*60, 60*60) dt <- as.POSIXct(x, origin=\"2000-01-01 00:00:00\") f <- as.POSIXlt(dt)$hour %[]% c(0, 11) plot(sin(x) ~ dt, type=\"l\", col=\"grey\",     main = \"Filtering date/time objects\") points(sin(x) ~ dt, pch = 19, col = f + 1)   ## watch precedence (2 * 1:5) %[]% (c(2, 3) * 2) #> [1] FALSE  TRUE  TRUE FALSE FALSE 2 * 1:5 %[]% (c(2, 3) * 2) #> [1] 0 0 0 2 2 (2 * 1:5) %[]% c(2, 3) * 2 #> [1] 2 0 0 0 0 2 * 1:5 %[]% c(2, 3) * 2 #> [1] 0 4 4 0 0"},{"path":"/reference/ni.html","id":null,"dir":"Reference","previous_headings":"","what":"Negated Value Matching — %ni%","title":"Negated Value Matching — %ni%","text":"%ni% negation %%, returns logical vector indicating non-match left operand. %nin% %notin% aliases better code readability (%% can look much like %ni%).","code":""},{"path":"/reference/ni.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Negated Value Matching — %ni%","text":"","code":"x %ni% table x %nin% table x %notin% table"},{"path":"/reference/ni.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Negated Value Matching — %ni%","text":"x vector NULL: values matched. table vector NULL: values matched .","code":""},{"path":"/reference/ni.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Negated Value Matching — %ni%","text":"logical vector, indicating non-match located element x: thus values TRUE FALSE never NA.","code":""},{"path":"/reference/ni.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Negated Value Matching — %ni%","text":"Peter Solymos <solymos@ualberta.ca>","code":""},{"path":[]},{"path":"/reference/ni.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Negated Value Matching — %ni%","text":"","code":"1:10 %ni% c(1,3,5,9) #>  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE 1:10 %nin% c(1,3,5,9) #>  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE 1:10 %notin% c(1,3,5,9) #>  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE  sstr <- c(\"c\",\"ab\",\"B\",\"bba\",\"c\",NA,\"@\",\"bla\",\"a\",\"Ba\",\"%\") sstr[sstr %ni% c(letters, LETTERS)] #> [1] \"ab\"  \"bba\" NA    \"@\"   \"bla\" \"Ba\"  \"%\""},{"path":"/reference/ovrlap.html","id":null,"dir":"Reference","previous_headings":"","what":"Relational Operators Comparing Two Intervals — ovrlap","title":"Relational Operators Comparing Two Intervals — ovrlap","text":"Functions evaluating two intervals overlap .","code":""},{"path":"/reference/ovrlap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Relational Operators Comparing Two Intervals — ovrlap","text":"","code":"interval1 %[o]% interval2 interval1 %)o(% interval2 interval1 %[<o]% interval2 interval1 %[o>]% interval2  interval1 %(o)% interval2 interval1 %]o[% interval2 interval1 %(<o)% interval2 interval1 %(o>)% interval2  interval1 %[]o[]% interval2 interval1 %[]o[)% interval2 interval1 %[]o(]% interval2 interval1 %[]o()% interval2 interval1 %[)o[]% interval2 interval1 %[)o[)% interval2 interval1 %[)o(]% interval2 interval1 %[)o()% interval2 interval1 %(]o[]% interval2 interval1 %(]o[)% interval2 interval1 %(]o(]% interval2 interval1 %(]o()% interval2 interval1 %()o[]% interval2 interval1 %()o[)% interval2 interval1 %()o(]% interval2 interval1 %()o()% interval2"},{"path":"/reference/ovrlap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Relational Operators Comparing Two Intervals — ovrlap","text":"interval1, interval2 vector, 2-column matrix, list, NULL: interval end points two (sets) closed intervals compare.","code":""},{"path":"/reference/ovrlap.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Relational Operators Comparing Two Intervals — ovrlap","text":"operators define open/closed nature lower/upper limits intervals left right hand side o middle. overlap two closed intervals, [a1, b1] [a2, b2], evaluated %[o]% (alias %[]o[]%) operator (a1 <= b1, a2 <= b2). Endpoints can defined vector two values (c(a1, b1))can stored matrix-like objects lists case comparisons made element-wise. lengths match, shorter objects recycled. value--interval operators work numeric (integer, real) ordered vectors, object types measured least ordinal scale (e.g. dates), see Examples. Note: interval endpoints sorted internally thus ensuring conditions a1 <= b1 a2 <= b2 necessary. %)o(% used negation two closed interval overlap, directional evaluation done via operators %[<o]% %[o>]%. overlap two open intervals evaluated %(o)% (alias %()o()%). %]o[% used negation two open interval overlap, directional evaluation done via operators %(<o)% %(o>)%. Overlap operators mixed endpoint negation directional counterparts.","code":""},{"path":"/reference/ovrlap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Relational Operators Comparing Two Intervals — ovrlap","text":"logical vector, indicating interval1 overlaps interval2. Values TRUE, FALSE, NA.","code":""},{"path":"/reference/ovrlap.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Relational Operators Comparing Two Intervals — ovrlap","text":"Peter Solymos <solymos@ualberta.ca>","code":""},{"path":[]},{"path":"/reference/ovrlap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Relational Operators Comparing Two Intervals — ovrlap","text":"","code":"## motivating examples from example(lm)  ## Annette Dobson (1990) \"An Introduction to Generalized Linear Models\". ## Page 9: Plant Weight Data. ctl <- c(4.17,5.58,5.18,6.11,4.50,4.61,5.17,4.53,5.33,5.14) trt <- c(4.81,4.17,4.41,3.59,5.87,3.83,6.03,4.89,4.32,4.69) group <- gl(2, 10, 20, labels = c(\"Ctl\",\"Trt\")) weight <- c(ctl, trt) lm.D90 <- lm(weight ~ group - 1) # omitting intercept ## compare 95% confidence of the 2 groups to each other (CI.D90 <- confint(lm.D90)) #>            2.5 %  97.5 % #> groupCtl 4.56934 5.49466 #> groupTrt 4.19834 5.12366 CI.D90[1,] %[o]% CI.D90[2,] #> 2.5 %  #>  TRUE   ## simple interval comparisons c(2:3) %[o]% c(0:1) #> [1] FALSE  ## vectorized comparisons c(2:3) %[o]% list(0:4, 1:5) #> [1] FALSE  TRUE  TRUE  TRUE FALSE c(2:3) %[o]% cbind(0:4, 1:5) #> [1] FALSE  TRUE  TRUE  TRUE FALSE c(2:3) %[o]% data.frame(a=0:4, b=1:5) #> [1] FALSE  TRUE  TRUE  TRUE FALSE list(0:4, 1:5) %[o]% c(2:3) #> [1] FALSE  TRUE  TRUE  TRUE FALSE cbind(0:4, 1:5) %[o]% c(2:3) #> [1] FALSE  TRUE  TRUE  TRUE FALSE data.frame(a=0:4, b=1:5) %[o]% c(2:3) #> [1] FALSE  TRUE  TRUE  TRUE FALSE  list(0:4, 1:5) %[o]% cbind(rep(2,5), rep(3,5)) #> [1] FALSE  TRUE  TRUE  TRUE FALSE cbind(rep(2,5), rep(3,5)) %[o]% list(0:4, 1:5) #> [1] FALSE  TRUE  TRUE  TRUE FALSE  cbind(rep(3,5),rep(4,5)) %)o(% cbind(1:5, 2:6) #> [1]  TRUE FALSE FALSE FALSE  TRUE cbind(rep(3,5),rep(4,5)) %[<o]% cbind(1:5, 2:6) #> [1] FALSE FALSE FALSE FALSE  TRUE cbind(rep(3,5),rep(4,5)) %[o>]% cbind(1:5, 2:6) #> [1]  TRUE FALSE FALSE FALSE FALSE  ## open intervals  list(0:4, 1:5) %(o)% cbind(rep(2,5), rep(3,5)) #> [1] FALSE FALSE  TRUE FALSE FALSE cbind(rep(2,5), rep(3,5)) %(o)% list(0:4, 1:5) #> [1] FALSE FALSE  TRUE FALSE FALSE  cbind(rep(3,5),rep(4,5)) %]o[% cbind(1:5, 2:6) #> [1]  TRUE  TRUE FALSE  TRUE  TRUE cbind(rep(3,5),rep(4,5)) %(<o)% cbind(1:5, 2:6) #> [1] FALSE FALSE FALSE  TRUE  TRUE cbind(rep(3,5),rep(4,5)) %(o>)% cbind(1:5, 2:6) #> [1]  TRUE  TRUE FALSE FALSE FALSE  dt1 <- as.Date(c(\"2000-01-01\", \"2000-03-15\")) dt2 <- as.Date(c(\"2000-03-15\", \"2000-06-07\"))  dt1 %[]o[]% dt2 #> [1] TRUE dt1 %[]o[)% dt2 #> [1] TRUE dt1 %[]o(]% dt2 #> [1] FALSE dt1 %[]o()% dt2 #> [1] FALSE dt1 %[)o[]% dt2 #> [1] FALSE dt1 %[)o[)% dt2 #> [1] FALSE dt1 %[)o(]% dt2 #> [1] FALSE dt1 %[)o()% dt2 #> [1] FALSE dt1 %(]o[]% dt2 #> [1] TRUE dt1 %(]o[)% dt2 #> [1] TRUE dt1 %(]o(]% dt2 #> [1] FALSE dt1 %(]o()% dt2 #> [1] FALSE dt1 %()o[]% dt2 #> [1] FALSE dt1 %()o[)% dt2 #> [1] FALSE dt1 %()o(]% dt2 #> [1] FALSE dt1 %()o()% dt2 #> [1] FALSE  ## watch precedence (2 * c(1, 3)) %[o]% (c(2, 4) * 2) #> [1] TRUE (2 * c(1, 3)) %[o]% c(2, 4) * 2 #> [1] 2 2 * c(1, 3) %[o]% (c(2, 4) * 2) #> [1] 0 2 * c(1, 3) %[o]% c(2, 4) * 2 #> [1] 4"},{"path":"/news/index.html","id":"version-01-3--may-19-2024","dir":"Changelog","previous_headings":"","what":"Version 0.1-3 – May 19, 2024","title":"Version 0.1-3 – May 19, 2024","text":"CRAN release: 2024-05-20 Maintainer email changed personal.","code":""},{"path":"/news/index.html","id":"version-01-2--august-11-2020","dir":"Changelog","previous_headings":"","what":"Version 0.1-2 – August 11, 2020","title":"Version 0.1-2 – August 11, 2020","text":"CRAN release: 2020-08-12 Added functions %[c]%, %[c)%, %(c]%, %(c)% divide range 3 intervals. Added aliases %nin% %notin% %ni% better code readability.","code":""},{"path":"/news/index.html","id":"version-01-1--january-21-2017","dir":"Changelog","previous_headings":"","what":"Version 0.1-1 – January 21, 2017","title":"Version 0.1-1 – January 21, 2017","text":"CRAN release: 2017-01-22 NA handling inconsistency fixed documented (#8). possible interval--interval operators added (#6).","code":""},{"path":"/news/index.html","id":"version-01-0--december-5-2016","dir":"Changelog","previous_headings":"","what":"Version 0.1-0 – December 5, 2016","title":"Version 0.1-0 – December 5, 2016","text":"CRAN release: 2016-12-06 CRAN release version. Functions finalized. Documentation tests added.","code":""},{"path":"/news/index.html","id":"version-00-1--november-26-2016","dir":"Changelog","previous_headings":"","what":"Version 0.0-1 – November 26, 2016","title":"Version 0.0-1 – November 26, 2016","text":"Initial bunch functions.","code":""}]
